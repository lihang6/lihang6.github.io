(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{614:function(s,t,a){"use strict";a.r(t);var n=a(15),e=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"数据类型进阶"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据类型进阶"}},[s._v("#")]),s._v(" 数据类型进阶")]),s._v(" "),a("p",[s._v("本节主要讲解数据类型当中字符编码的概括以及类型转换、引用类型的理解。")]),s._v(" "),a("h2",{attrs:{id:"为什么要编码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要编码"}},[s._v("#")]),s._v(" 为什么要编码？")]),s._v(" "),a("p",[s._v("在面试时可能会提到这些问题，而且在以后的学习中可能会见到字符编码，所以大家对概念一定要有个了解。"),a("br"),s._v("\n为什么要编码:"),a("br"),s._v("\n因为计算机能理解的语言是二进制的（0,1），人类的语言（英文、中文以及其它语言）计算机是无法直接理解的，同样，计算机的二进制语言，人类也是无法直接理解的，所以需要进行转换，这个转换的过程就叫编解码。\n由字符到字节叫编码，由字节到字符叫解码。")]),s._v(" "),a("p",[s._v("下面是六种字符编码的简单介绍:")]),s._v(" "),a("ul",[a("li",[s._v("ASCII 编码:美国信息互换标准代码， 用一个字节来编码。")]),s._v(" "),a("li",[s._v("ISO-8859-1 字符编码:是国际化标准组织位西欧语言制定的编码， 它用一个字节来为字符编码， 与 ASCII 编码兼容。")]),s._v(" "),a("li",[s._v("GB2312 字符编码:它包括对简体中文字符的编码。")]),s._v(" "),a("li",[s._v("GBK 字符编码:它是对 GB2312 编码的扩展， 收录了更多的中文字符。")]),s._v(" "),a("li",[s._v("Unicode 字符编码:收录了全世界所有语言文字中的字符")]),s._v(" "),a("li",[s._v("UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码。")])]),s._v(" "),a("h2",{attrs:{id:"类型转换补充概括"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型转换补充概括"}},[s._v("#")]),s._v(" 类型转换补充概括")]),s._v(" "),a("p",[s._v("Java 语言是一种强类型的语言。强类型的语言有以下几个要求：")]),s._v(" "),a("p",[s._v("变量或常量必须有类型:要求声明变量或常量时必须声明类型，而且只能在声明以后才能使用。")]),s._v(" "),a("p",[s._v("赋值时类型必须一致:值的类型必须和变量或常量的类型完全一致。")]),s._v(" "),a("p",[s._v("运算时类型必须一致:参与运算的数据类型必须一致才能运算。")]),s._v(" "),a("p",[s._v("但是在实际的使用中，经常需要在不同类型的值之间进行操作，这就需要一种新的语法来适应这种需要，这个语法就是数据类型转换。"),a("br"),s._v("\n在数值处理这部分，计算机和现实的逻辑不太一样，对于现实来说，1和 1.0 没有什么区别，但是对于计算机来说，1 是整数类型，而 1.0 是小数类型，其在内存中的存储方式以及占用的空间都不一样，所以类型转换在计算机内部是必须的。")]),s._v(" "),a("p",[s._v("Java 语言中的数据类型转换有两种：")]),s._v(" "),a("p",[s._v("自动类型转换:编译器自动完成类型转换，不需要在程序中编写代码。")]),s._v(" "),a("p",[s._v("强制类型转换:强制编译器进行类型转换，必须在程序中编写代码。")]),s._v(" "),a("p",[s._v("由于基本数据类型中 boolean 类型不是数字型，所以基本数据类型的转换是出了 boolean 类型以外的其它 7 种类型之间的转换。下面来具体介绍两种类型转换的规则、适用场合以及使用时需要注意的问题。")]),s._v(" "),a("h2",{attrs:{id:"自动类型转换补充"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自动类型转换补充"}},[s._v("#")]),s._v(" 自动类型转换补充")]),s._v(" "),a("p",[s._v("自动类型转换，也称隐式类型转换，是指不需要书写代码，由系统自动完成的类型转换。由于实际开发中这样的类型转换很多，所以 Java 语言在设计时，没有为该操作设计语法，而是由 JVM 自动完成。")]),s._v(" "),a("p",[s._v("转换规则：从存储范围小的类型到存储范围大的类型。"),a("br"),s._v("\n具体规则为：byte→short(char)→int→long→float→double")]),s._v(" "),a("p",[s._v("也就是说 byte 类型的变量可以自动转换为 short 类型，示例代码：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("byte  b  "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("  "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nshort sh "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("这里在赋值时，"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JVM")]),s._v(" 首先将 b 的值转换为 short 类型，然后再赋值给 sh。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("在类型转换时可以跳跃。示例代码：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("byte  b1  "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("  "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nint  n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("  b1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("注意问题:在整数之间进行类型转换时，数值不发生改变，而将整数类型，特别是比较大的整数类型转换成小数类型时，由于存储方式不同，有可能存在数据精度的损失。"),a("br"),s._v("\n注意在类型转换的时候,默认是int类型")]),s._v(" "),a("h2",{attrs:{id:"强制类型转换补充"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强制类型转换补充"}},[s._v("#")]),s._v(" 强制类型转换补充")]),s._v(" "),a("p",[s._v("强制类型转换，也称显式类型转换，是指必须书写代码才能完成的类型转换。该类类型转换很可能存在精度的损失，所以必须书写相应的代码，并且能够忍受该种损失时才进行该类型的转换。")]),s._v(" "),a("p",[s._v("转换规则:从存储范围大的类型到存储范围小的类型。")]),s._v(" "),a("p",[s._v("具体规则为：double→float→long→int→short(char)→byte")]),s._v(" "),a("p",[s._v("语法格式为：(转换到的类型)需要转换的值")]),s._v(" "),a("p",[s._v("示例代码：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("double  d  "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("  "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3.10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nint  n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("int"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("d"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("这里将 double 类型的变量 d 强制转换成 int 类型，然后赋值给变量 n。需要说明的是小数强制转换为整数，采用的是“去 1 法”，也就是无条件的舍弃小数点的所有数字，则以上转换出的结果是 3。整数强制转换为整数时取数字的低位，例如 int 类型的变量转换为 byte 类型时，则只去 int 类型的低 8 位(也就是最后一个字节)的值。")]),s._v(" "),a("p",[s._v("示例代码：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("int  n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("  "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("123")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nbyte  b  "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("byte"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nint  m  "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("  "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1234")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nbyte  b1  "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("byte"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("m"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("则 b 的值还是 123，而 b1 的值为-46。b1 的计算方法如下：m 的值转换为二进制是10011010010，取该数字低8位的值作为b1的值，则b1的二进制值是11010010，按照机器数的规定，最高位是符号位，1 代表负数，在计算机中负数存储的是补码，则该负数的原码是 10101110，该值就是十进制的-46。"),a("br"),s._v("\n注意问题:强制类型转换通常都会存储精度的损失，所以使用时需要谨慎。")])])}),[],!1,null,null,null);t.default=e.exports}}]);